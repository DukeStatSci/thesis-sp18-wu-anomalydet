# }
# else {
#   EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
# }
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
#Replacing only missing means we cant assess fitted error
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
RMSEs = lapply(seq(2,5,1), function(k) loocv(250,k, 20, 20, Y, M)$RMSE)
#Leave One Out Cross Validation
loocv = function (S = 1000, k = 2, nrows = nrows, ncols = ncols, Y, M){
error = 0
rmse = 0
n = 0
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] != 0){
n = n + 1
M_imputed = M
true_sd = Y[i,j]
M_imputed[i,j] = 0
Y_imputed = matrix_complete(S, k, nrows, ncols, Y, M_imputed)
error = error + abs((Y_imputed[i,j] - Y[i,j]))
rmse = rmse + (Y_imputed[i,j] - Y[i,j])^2
}
}
}
rmse = sqrt(rmse/n)
return (list(Error = error, RMSE = rmse, Observations = n))
}
setwd("~/Desktop/Stats Thesis/thesis-sp18-wu-anomalydet/index")
Y = readRDS("data/means.RDS")
M = readRDS("data/freqs.RDS")
RMSEs = lapply(seq(2,5,1), function(k) loocv(250,k, 20, 20, Y, M)$RMSE)
RMSEs
RMSEs = lapply(seq(2,10,1), function(k) loocv(250,k, 20, 20, Y, M)$RMSE)
RMSEs
plot(seq(2,10,1), RMSEs)
x = readRDS("data/rank6_normal.RDS")
og = readRDS("data/rank6_normal.RDS")
num_missing = 74
for (s in 1:num_missing){
i = sample(1:10, 1)
j = sample(1:10, 1)
if (!is.na(x[i,j])){
x[i,j] = NA
}
else{
s = s - 1
}
}
m = x
for (i in 1:10){
for (j in 1:10){
if(is.na(m[i,j])){
m[i,j] = 0
}
else{
m[i,j] = 1
}
}
}
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
plot(seq(2,10,1), cvs)
cvs
cvs = lapply(seq(1,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
####Eckhart Young Theorem Implementation, Best Rank k Approximation####
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
if (k == 1){
EYM = U[,1] %*% diag((svd_Y$d)[1]) %*% t(V[,1]) #do you take the transpose first or after taking the column?
}
else {
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
}
# EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
#Replacing only missing means we cant assess fitted error
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
cvs = lapply(seq(1,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
svd_Y = svd(Y_imputed)
Y_imputed = Y
svd_Y = svd(Y_imputed)
a
Y = readRDS("data/means.RDS")
Y_imputed = Y
svd_Y = svd(Y_imputed)
svd(Y)
Y
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (i in 1:20){
for (j in 1:20){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:20){
for (j in 1:20){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
Y_imputed
svd_Y = svd(Y_imputed)
svd_Y
U = svd_Y$u
V = svd_Y$v
U
svd_Y
U
U[1,]
####Eckhart Young Theorem Implementation, Best Rank k Approximation####
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
# if (k == 1){
#   EYM = U[,1] %*% diag((svd_Y$d)[1]) %*% t(V[,1]) #do you take the transpose first or after taking the column?
# }
# else {
#   EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
# }
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V)[,1:k]
#Replacing only missing means we cant assess fitted error
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
cvs = lapply(seq(1,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
####Eckhart Young Theorem Implementation, Best Rank k Approximation####
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
# if (k == 1){
#   EYM = U[,1] %*% diag((svd_Y$d)[1]) %*% t(V[,1]) #do you take the transpose first or after taking the column?
# }
# else {
#   EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
# }
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V)[,1:k]
#Replacing only missing means we cant assess fitted error
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
setwd("~/Desktop/Stats Thesis/thesis-sp18-wu-anomalydet/index")
Y = readRDS("data/means.RDS")
M = readRDS("data/freqs.RDS")
####Eckhart Young Theorem Implementation, Best Rank k Approximation####
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
# if (k == 1){
#   EYM = U[,1] %*% diag((svd_Y$d)[1]) %*% t(V[,1]) #do you take the transpose first or after taking the column?
# }
# else {
#   EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
# }
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
#Replacing only missing means we cant assess fitted error
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
x = readRDS("data/rank6_normal.RDS")
og = readRDS("data/rank6_normal.RDS")
num_missing = 74
for (s in 1:num_missing){
i = sample(1:10, 1)
j = sample(1:10, 1)
if (!is.na(x[i,j])){
x[i,j] = NA
}
else{
s = s - 1
}
}
m = x
for (i in 1:10){
for (j in 1:10){
if(is.na(m[i,j])){
m[i,j] = 0
}
else{
m[i,j] = 1
}
}
}
cvs = lapply(seq(1,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
plot(seq(2,10,1), cvs)
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
# if (k == 1){
#   EYM = U[,1] %*% diag((svd_Y$d)[1]) %*% t(V[,1]) #do you take the transpose first or after taking the column?
# }
# else {
#   EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
# }
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V)[,1:k]
#Replacing only missing means we cant assess fitted error
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
####Eckhart Young Theorem Implementation, Best Rank k Approximation####
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
# if (k == 1){
#   EYM = U[,1] %*% diag((svd_Y$d)[1]) %*% t(V[,1]) #do you take the transpose first or after taking the column?
# }
# else {
#   EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
# }
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V)[1:k,]
#Replacing only missing means we cant assess fitted error
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
plot(seq(2,10,1), cvs)
cvs
x
og
qr(og)$rank
rankMatrix(og)
require(Matrix)
rankMatrix(og)
q
qr
qr(x)$rank
x
og = readRDS("data/rank6_normal.RDS")
num_missing = 74
for (s in 1:num_missing){
i = sample(1:10, 1)
j = sample(1:10, 1)
if (!is.na(x[i,j])){
x[i,j] = NA
}
else{
s = s - 1
}
}
m = x
for (i in 1:10){
for (j in 1:10){
if(is.na(m[i,j])){
m[i,j] = 0
}
else{
m[i,j] = 1
}
}
}
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
plot(seq(2,10,1), cvs)
x = readRDS("data/rank6_normal.RDS")
og = readRDS("data/rank6_normal.RDS")
num_missing = 74
for (s in 1:num_missing){
i = sample(1:10, 1)
j = sample(1:10, 1)
if (!is.na(x[i,j])){
x[i,j] = NA
}
else{
s = s - 1
}
}
m = x
for (i in 1:10){
for (j in 1:10){
if(is.na(m[i,j])){
m[i,j] = 0
}
else{
m[i,j] = 1
}
}
}
cvs = lapply(seq(2,10,1), function(k) loocv(200,k,10,10,x,m)$RMSE)
plot(seq(2,10,1), cvs)
