z = rep(1,dim(X)[2] )
for(s in 1:S) {
for(j in sample(1:p)){
z1=z0=z  ; z1[j]=1 ; z0[j]=0
r=lmgp(z0,z1,y,X)
z[j]=rbinom(1,1,1/(1+exp(-r)))
}
Z=rbind(Z,z)
}
}
mselect.gprior(y,X)
a
lmgp=function(z0,z1,y,X,g=dim(X)[1],nu0=1,
s200=mean( lm(y~-1+X[,z0==1])$res^2),
s201=mean( lm(y~-1+X[,z1==1])$res^2)) {
n=dim(X)[1]
X0=X[,z0==1]
X1=X[,z1==1]
H0= (g/(g+1)) * X0%*%solve(t(X0)%*%X0)%*%t(X0)
SS0= t(y)%*%( diag(1,nrow=n)  - H0 ) %*%y
p0=sum(z0==1)
H1= (g/(g+1)) * X1%*%solve(t(X1)%*%X1)%*%t(X1)
SS1= t(y)%*%( diag(1,nrow=n)  - H1 ) %*%y
p1=sum(z1==1)
-.5*(p1-p0)*log( 2*pi*(1+g))  +
.5*nu0*log(s201/s200) + .5*(nu0+n)*log( (nu0*s200+SS0)/(nu0+s201+SS1) )
}
mselect.gprior = function(y,X,S=1000,verb=FALSE){
Z = NULL
z = rep(1,dim(X)[2] )
for(s in 1:S) {
for(j in sample(1:p)){
z1=z0=z  ; z1[j]=1 ; z0[j]=0
r=lmgp(z0,z1,y,X)
z[j]=rbinom(1,1,1/(1+exp(-r)))
}
Z=rbind(Z,z)
}
}
mselect.gprior(y,X)
RMSEs = c (42727.19, 31878.69, 44605.58, 48193.36, 46903.49, 47509.22, 47807.57, 48136.36 )
plot(seq(1,8,1), RMSEs)
means
library(lattice)
library(reshape)
library(igraph)
setwd("~/Desktop/Stats Thesis/thesis-sp18-wu-anomalydet/index")
argus = readRDS("data/argus_complete.rds")
means = readRDS("data/means.RDS")
vars = readRDS("data/vars.RDS")
freqs = readRDS("data/freqs.RDS")
combos = readRDS("data/combos.RDS")
means
sbyte_means = readRDS("data/means_SB.rds")
spkt_means = readRDS("data/means_SP.rds")
dbyte_means = readRDS("data/means_DB.rds")
dpkt_means = readRDS("data/means_DP.rds")
means
sbyte_means = readRDS("data/means_SB.rds")
combos = readRDS("data/combos.RDS")
sbyte_means = readRDS("data/means_SB.rds")
spkt_means = readRDS("data/means_SP.rds")
dbyte_means = readRDS("data/means_DB.rds")
dpkt_means = readRDS("data/means_DP.rds")
sbyte_means
dim(sbyte_means)
sbyte_means[1:20, 1;20]
sbyte_means[1:20, 1:20]
dim(sbyte_means[1:20, 1:20])
sbyte_means = readRDS("data/means_SB.rds")[1:20, 1:20]
spkt_means = readRDS("data/means_SP.rds")[1:20, 1:20]
dbyte_means = readRDS("data/means_DB.rds")[1:20, 1:20]
dpkt_means = readRDS("data/means_DP.rds")[1:20, 1:20]
### ROW MEANS/COL MEANS VISUALIZATION
sb_row_means = rowMeans(sbyte_means, na.rm = TRUE)
sb_col_means = colMeans(sbyte_means, na.rm = TRUE)
sp_row_means = rowMeans(spkt_means, na.rm = TRUE)
sp_col_means = colMeans(spkt_means, na.rm = TRUE)
db_row_means = rowMeans(dbyte_means, na.rm = TRUE)
db_col_means = colMeans(dbyte_means, na.rm = TRUE)
dp_row_means = rowMeans(dpkt_means, na.rm = TRUE)
dp_col_means = colMeans(dpkt_means, na.rm = TRUE)
ggplot(data = sb_row_means)
library(ggplot2)
ggplot(data=sb_row_means, aes(x=dose, y=len)) +
geom_bar(stat="identity", color="blue", fill="white")
sb_row_means = rowMeans(sbyte_means, na.rm = TRUE)
sb_col_means = colMeans(sbyte_means, na.rm = TRUE)
sp_row_means = rowMeans(spkt_means, na.rm = TRUE)
sp_col_means = colMeans(spkt_means, na.rm = TRUE)
db_row_means = rowMeans(dbyte_means, na.rm = TRUE)
db_col_means = colMeans(dbyte_means, na.rm = TRUE)
dp_row_means = rowMeans(dpkt_means, na.rm = TRUE)
dp_col_means = colMeans(dpkt_means, na.rm = TRUE)
sbyte_means = readRDS("data/means_SB.rds")[1:20, 1:20]
spkt_means = readRDS("data/means_SP.rds")[1:20, 1:20]
dbyte_means = readRDS("data/means_DB.rds")[1:20, 1:20]
dpkt_means = readRDS("data/means_DP.rds")[1:20, 1:20]
### ROW MEANS/COL MEANS VISUALIZATION
sb_row_means = rowMeans(sbyte_means, na.rm = TRUE)
sb_col_means = colMeans(sbyte_means, na.rm = TRUE)
sp_row_means = rowMeans(spkt_means, na.rm = TRUE)
sp_col_means = colMeans(spkt_means, na.rm = TRUE)
db_row_means = rowMeans(dbyte_means, na.rm = TRUE)
db_col_means = colMeans(dbyte_means, na.rm = TRUE)
dp_row_means = rowMeans(dpkt_means, na.rm = TRUE)
dp_col_means = colMeans(dpkt_means, na.rm = TRUE)
#geombarplot, ggextra - grid arrange use ggplot use ggplot
par(mfrow=c(4,2))
barplot(sb_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(sb_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
barplot(sp_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(sp_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
barplot(db_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(db_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
barplot(dp_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(dp_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
main = "Column Means of SrcBytes Matrix")
sbyte_means = readRDS("data/means_SB.rds")[1:20, 1:20]
spkt_means = readRDS("data/means_SP.rds")[1:20, 1:20]
dbyte_means = readRDS("data/means_DB.rds")[1:20, 1:20]
dpkt_means = readRDS("data/means_DP.rds")[1:20, 1:20]
### ROW MEANS/COL MEANS VISUALIZATION
sb_row_means = rowMeans(sbyte_means, na.rm = TRUE)
sb_col_means = colMeans(sbyte_means, na.rm = TRUE)
sp_row_means = rowMeans(spkt_means, na.rm = TRUE)
sp_col_means = colMeans(spkt_means, na.rm = TRUE)
db_row_means = rowMeans(dbyte_means, na.rm = TRUE)
db_col_means = colMeans(dbyte_means, na.rm = TRUE)
dp_row_means = rowMeans(dpkt_means, na.rm = TRUE)
dp_col_means = colMeans(dpkt_means, na.rm = TRUE)
#geombarplot, ggextra - grid arrange use ggplot use ggplot
par(mfrow=c(4,2))
barplot(sb_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(sb_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
barplot(sp_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(sp_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
barplot(db_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(db_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
barplot(dp_row_means, las=2, xlab = "Source Port", ylab = "Mean (SrcBytes)",
main = "Row Means of SrcBytes Matrix")
barplot(dp_col_means, las=2, xlab = "Destination Port", ylab = "Mean (SrcBytes)",
main = "Column Means of SrcBytes Matrix")
#set counts
s_num = 25
d_num = 25
combo_num = 20
#get top sport and dport values
Sport_table = table(Sport)
Sport_table = as.data.frame(Sport_table)
Sport_table = Sport_table[order(-Sport_table$Freq),]
top_Sport = (head(Sport_table$Sport, s_num))
Dport_table = table(Dport)
Dport_table = as.data.frame(Dport_table)
Dport_table = Dport_table[order(-Dport_table$Freq),]
top_Dport = (head(Dport_table$Dport, d_num))
#subset data for the combinations
argus_maxes = argus[is.element(Sport, top_Sport) & is.element(Dport, top_Dport), ]
argus_maxes = transform(argus_maxes,
Sport = as.numeric(as.character(Sport)),
Dport = as.numeric(as.character(Dport)))
max_combinations = as.data.frame(table(argus_maxes$Sport, argus_maxes$Dport))
top_combinations = head(max_combinations[order(-max_combinations$Freq),], combo_num)
top_combinations$Sport = top_combinations$Var1
top_combinations$Dport = top_combinations$Var2
top_combinations$Var1 = NULL
top_combinations$Var2 = NULL
top_combinations = transform(top_combinations,
Sport = as.numeric(as.character(Sport)),
Dport = as.numeric(as.character(Dport)))
#generate the combinations matrix of ports
extract_intersection = function(sport, dport){
argus_subset = argus[Sport == sport & Dport == dport,]
return (argus_subset)
}
generate_combinations_matrix = function(top_combinations){
n = dim(top_combinations)[1]
combinations = c()
for (i in 1:n){
sport = as.numeric(top_combinations[i,]$Sport)
dport = as.numeric(top_combinations[i,]$Dport)
combo = extract_intersection(sport, dport)
combinations = c(combinations, list(combo))
}
return (combinations)
}
combinations = generate_combinations_matrix(top_combinations)
argus = readRDS("data/argus_complete.rds")
sapply(argus, class)
argus = transform(argus,
Sport = as.factor(argus$Sport),
Dport = as.factor(argus$Dport))
argus = subset(argus, select = c("Flgs", "SrcAddr", "Sport", "DstAddr", "Dport",
"SrcPkts", "DstPkts", "SrcBytes", "DstBytes", "State"))
attach(argus)
#set counts
s_num = 25
d_num = 25
combo_num = 20
#get top sport and dport values
Sport_table = table(Sport)
Sport_table = as.data.frame(Sport_table)
Sport_table = Sport_table[order(-Sport_table$Freq),]
top_Sport = (head(Sport_table$Sport, s_num))
Dport_table = table(Dport)
Dport_table = as.data.frame(Dport_table)
Dport_table = Dport_table[order(-Dport_table$Freq),]
top_Dport = (head(Dport_table$Dport, d_num))
#subset data for the combinations
argus_maxes = argus[is.element(Sport, top_Sport) & is.element(Dport, top_Dport), ]
argus_maxes = transform(argus_maxes,
Sport = as.numeric(as.character(Sport)),
Dport = as.numeric(as.character(Dport)))
max_combinations = as.data.frame(table(argus_maxes$Sport, argus_maxes$Dport))
top_combinations = head(max_combinations[order(-max_combinations$Freq),], combo_num)
top_combinations$Sport = top_combinations$Var1
top_combinations$Dport = top_combinations$Var2
top_combinations$Var1 = NULL
top_combinations$Var2 = NULL
top_combinations = transform(top_combinations,
Sport = as.numeric(as.character(Sport)),
Dport = as.numeric(as.character(Dport)))
#generate the combinations matrix of ports
extract_intersection = function(sport, dport){
argus_subset = argus[Sport == sport & Dport == dport,]
return (argus_subset)
}
generate_combinations_matrix = function(top_combinations){
n = dim(top_combinations)[1]
combinations = c()
for (i in 1:n){
sport = as.numeric(top_combinations[i,]$Sport)
dport = as.numeric(top_combinations[i,]$Dport)
combo = extract_intersection(sport, dport)
combinations = c(combinations, list(combo))
}
return (combinations)
}
combinations = generate_combinations_matrix(top_combinations)
combinations
saveRDS(combinations, "pca_combo.rds")
saveRDS(combinations, "data/pca_combo.rds")
setwd("~/Desktop/Stats Thesis/thesis-sp18-wu-anomalydet/index")
saveRDS(combinations, "data/pca_combo.rds")
test = readRDS("combos.rds")
test = readRDS("combos.RDS")
test = readRDS("data/combos.RDS")
test
length(combinations)
#principal component analysis and visualizing results
pca_analysis = function(SrcBytes, SrcPkts, DstBytes, DstPkts){
pca_cont_vars = cbind(SrcBytes, SrcPkts, DstBytes, DstPkts)
pca = prcomp(pca_cont_vars, center = TRUE, scale. = TRUE)
print(pca$rotation)
print((summary(pca)))
#screeplot(pca, type="lines",col=3)
g = ggbiplot(pca, obs.scale = 1, var.scale = 1,
ellipse = TRUE,
circle = TRUE)
g = g + scale_color_discrete(name = '')
g = g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
return(pca$rotation)
}
combinations = readRDS("data/pca_combos.rds")
combo_num = c(1,20)
for (i in combo_num){
combo_table = combinations[i]
combo_table = transform(combo_table,
SrcBytes = as.numeric(SrcBytes),
SrcPkts = as.numeric(SrcPkts),
DstBytes = as.numeric(DstBytes),
DstPkts = as.numeric(DstPkts))
cat("Sport:", combo_table$Sport[1],"\t")
cat("Dport:", combo_table$Dport[1],"\n")
SrcBytes_norm =  nscore(combo_table$SrcBytes)$nscore
SrcPkts_norm =  nscore(combo_table$SrcPkts)$nscore
DstBytes_norm =  nscore(combo_table$DstBytes)$nscore
DstPkts_norm =  nscore(combo_table$DstPkts)$nscore
pca_analysis(SrcBytes_norm, SrcPkts_norm, DstBytes_norm, DstPkts_norm)
}
library(ggbiplot)
library(gridExtra)
#principal component analysis and visualizing results
pca_analysis = function(SrcBytes, SrcPkts, DstBytes, DstPkts){
pca_cont_vars = cbind(SrcBytes, SrcPkts, DstBytes, DstPkts)
pca = prcomp(pca_cont_vars, center = TRUE, scale. = TRUE)
print(pca$rotation)
print((summary(pca)))
#screeplot(pca, type="lines",col=3)
g = ggbiplot(pca, obs.scale = 1, var.scale = 1,
ellipse = TRUE,
circle = TRUE)
g = g + scale_color_discrete(name = '')
g = g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
return(pca$rotation)
}
combinations = readRDS("data/pca_combos.rds")
X = matrix(rnorm(m * m, mean=0, sd=1), m, m)
W = diag(x = rexp(m, mean=0, sd=1), nrow = m, ncol = m)
y = matrix(rnorm(m * 1, mean=0, sd=1), m, 1)
Y = readRDS("data/means_SB.rds")
M = readRDS("data/freqs.rds")
m = nrow(Y)
n = ncol(Y)
X = matrix(rnorm(m * m, mean=0, sd=1), m, m)
W = diag(x = rexp(m, mean=0, sd=1), nrow = m, ncol = m)
W = diag(x = rexp(m, mean=1), nrow = m, ncol = m)
W = diag(x = rexp(m), nrow = m, ncol = m)
y = matrix(rnorm(m * 1, mean=0, sd=1), m, 1)
gibbs_sampler = function (X, y, W, sigma2_0 = 1, S = 10){
m = nrow(X)
### prior values
nu_0 = 2
beta_0 = numeric(m)
gamma2 = 100
W_0 = diag(m) * gamma2 #W is m x m
### starting values
set.seed(1)
BETAs = list()
INV_SIGMAs = list()
beta = beta_0
BETAs[[1]] = beta
inv_sigma2 = 1 / sigma2_0
INV_SIGMAs[[1]] = inv_sigma2
### Gibbs sampling
for(s in 2:S) {
# generate a new Beta value from its full conditional
Sigma_n = ginv ( ( t(X) %*% ginv(W) %*% X ) / ( 1 / inv_sigma2 ) + ginv(W_0) )
beta_n = Sigma_n %*% ( ( t(X) %*% ginv(W) %*% y ) / ( 1 / inv_sigma2 ) + ginv(W_0) %*% beta_0)
beta = mvrnorm( 1, beta_n, Sigma_n )
# generate a new 1/sigma2 value from its full conditional
SSR_W = ( ginv( y - X %*% beta ) %*% W  %*% ( y - X %*% beta ))
inv_sigma2 = rgamma(1, ( nu_0 + m )/2, ( nu_0 * sigma2_0 + SSR_W) / 2)
BETAs[[s]] = beta
INV_SIGMAs[[s]] = inv_sigma2
}
return (list(BETAs = BETAs, INV_SIGMAs = INV_SIGMAs))
}
gibbs_sampler(X, y, W, 100)
library(MASS)
gibbs_sampler(X, y, W)
x = gibbs_sampler(X, y, W)
x$BETAs
p<-5
beta<-rnorm(p)
X = matrix(rnorm(m * p, mean=0, sd=1), m, p)
W = diag(x = rexp(m), nrow = m, ncol = m)
y = X%*%beta  + matrix(rnorm(m * 1, mean=0, sd=1), m, 1)
y
plot(beta, lm(y~ -1+ X)$coef)
abline(0,1)
rmses = c( 42727.19, 33187.69, 44605.58, 48193.36, 46903.49, 47509.22, 47807.57, 48136.36 )
plot (seq(1,8,1), rmses, xlab = "Matrix Rank", ylab = "Root Mean Square Errors",
main = "Leave One Out Cross Validation for Matrix Ranks")
Y = readRDS("data/means_SB.rds")
M = readRDS("data/freqs.rds")
Y_imputed = matrix_complete(250, 2, nrow(Y), ncol(Y), Y, M)
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
if (k == 1){
EYM = (matrix(U[,1:k]) * (svd_Y$d)[1:k]) %*% t(matrix(V[,1:k]))
}
else {
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
}
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = EYM[i,j]
}
}
}
}
return (Y_imputed)
}
### version of EYM that replaces the considers the entire fitted matrix
matrix_complete = function(S = 1000, k = 2, nrows, ncols, Y, M){
Y_imputed = Y
#overall mean
n = sum(M)
mu = sum(Y, na.rm = TRUE)/n
#calculate row means and col means
a_i = rowMeans(Y, na.rm = TRUE)
b_j = colMeans(Y, na.rm = TRUE)
#set NaN to 0 in means to fix anova fill in
a_i = sapply(a_i, function(x) if (!is.finite(x)) {0} else {x})
b_j = sapply(b_j, function(x) if (!is.finite(x)) {0} else {x})
#Fill in missing values in Y_imputed with ANOVA
#Y_imputed = outer(1:nrow(Y), 1:ncol(Y), function(r,c) ifelse(M[r,c] == 0, a_i[r] + b_j[c] - mu, Y[r,c]))
for (i in 1:nrows){
for (j in 1:ncols){
if (M[i,j] == 0){
Y_imputed[i,j] = a_i[i] + b_j[j] - mu
}
}
}
for (s in 1:S){
#extract SVD
svd_Y = svd(Y_imputed)
U = svd_Y$u
V = svd_Y$v
#EYM theorem
if (k == 1){
EYM = (matrix(U[,1:k]) * (svd_Y$d)[1:k]) %*% t(matrix(V[,1:k]))
}
else {
EYM = U[,1:k] %*% diag((svd_Y$d)[1:k]) %*% t(V[,1:k])
}
Y_imputed = EYM
}
return (Y_imputed)
}
Y_imputed = matrix_complete(250, 2, nrow(Y), ncol(Y), Y, M)
par(mfrow = c(1,2))
plot(Y[!is.na(Y)], Y_imputed[!is.na(Y)], xlab = "Observed Values of Y",
ylab = "Fitted Values of Y", main = "Observed vs Fitted Values of Y")
par(mfrow = c(1,2))
plot(Y[!is.na(Y)], Y_imputed[!is.na(Y)], xlab = "Observed Values of Y",
ylab = "Fitted Values of Y", main = "Observed vs Fitted Values of Y")
abline(0,1, col = "red")
plot(Y[!is.na(Y)], Y_imputed[!is.na(Y)], xlim = c(0,1000), ylim = c(0,1000),
xlab = "Observed Values of Y", ylab = "Fitted Values of Y",
main = "Observed vs Fitted Values of Y (max 1000)")
abline(0,1, col = "red")
par(mfrow = c(1,2))
plot(Y[!is.na(Y)], Y_imputed[!is.na(Y)], xlab = "Observed Values of Y",
ylab = "Fitted Values of Y", main = "Y Observed vs Fitted Values")
abline(0,1, col = "red")
plot(Y[!is.na(Y)], Y_imputed[!is.na(Y)], xlim = c(0,1000), ylim = c(0,1000),
xlab = "Observed Values of Y", ylab = "Fitted Values of Y",
main = "Limit 1000")
abline(0,1, col = "red")
par(mfrow = c(1,2))
plot(Y[!is.na(Y)], Y_imputed[!is.na(Y)], xlab = "Observed Values of Y",
ylab = "Fitted Values of Y", main = "Observed vs Fitted Values Y")
abline(0,1, col = "red")
plot(Y[!is.na(Y)], Y_imputed[!is.na(Y)], xlim = c(0,1000), ylim = c(0,1000),
xlab = "Observed Values of Y (max 1000)", ylab = "Fitted Values of Y (max 1000)",
main = "Observed vs Fitted Values Y")
abline(0,1, col = "red")
freqs20 = readRDS("data/freqs_20.RDS")
levelplot(log(freqs20), xlab = "Source Ports", ylab = "Destination Ports",
col.regions = heat.colors(16)[length(heat.colors(16)):1],
main = "Sample Sizes of Port Combinations",scales=list(x=list(rot=90)))
freqs20 = readRDS("data/freqs_20.RDS")
levelplot(log(freqs20), xlab = "Source Ports", ylab = "Destination Ports",
col.regions = heat.colors(16)[length(heat.colors(16)):1],
main = "Sample Sizes of Port Combinations (Log Scale)",scales=list(x=list(rot=90)))
levelplot(log(freqs20), xlab = "Source Ports", ylab = "Destination Ports",
col.regions = heat.colors(16)[length(heat.colors(16)):1],
main = "Sample Sizes of Port Combinations (Log Scale)",scales=list(x=list(rot=90)))
# Dataframe way
test = melt(means)
test = na.omit(test)
g = graph.data.frame(test)
V(g)$type <- 1
V(g)[name %in% top_Dport]$type <- 2
V(g)[name %in% top_Sport]$type <- 3
deg <- degree(g, mode="all")
V(g)$size <- deg
E(g)$width <- E(g)$weight * 3
E(g)$arrow.size <- .2
g = simplify(g, remove.multiple = T, remove.loops = T)
shape <- c("circle", "square", "circle")
col <- c("orange", "steelblue","red")
plot(g,
vertex.color = col[V(g)$type],
vertex.shape = shape[V(g)$type],
edge.arrow.size = 0.2
)
